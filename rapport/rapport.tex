\documentclass[pdftex,a4paper,titlepage,11pt,openright]{article}
\usepackage[T1]{fontenc}
\usepackage[utf8]{inputenc}
\usepackage[english,francais]{babel}
\usepackage{listings}
\usepackage{setspace}

\usepackage{avant}
\usepackage{fancyvrb}
\usepackage{fancyhdr}
\pagestyle{fancy}
\fancyhf{}
\fancyhead[LE,RO]{\itshape\thepage}
% \fancyhead[LO]{\itshape\rightmark}
% \fancyhead[RE]{\itshape\leftmark}
\renewcommand{\headrulewidth}{0.5pt}
\addtolength{\headheight}{0.5pt}
\renewcommand\footrulewidth{0pt}
\fancypagestyle{plain}{
    \fancyhead{}
    \renewcommand{\headrulewidth}{0pt}}
\usepackage{textcomp}
\usepackage{relsize}
\usepackage{amssymb}
\usepackage[colorlinks=true,linkcolor=black,citecolor=black,urlcolor=black,filecolor=black]{hyperref}
\usepackage{framed}
\usepackage{geometry}
\usepackage[pdftex]{graphicx}
\usepackage{makeidx}
\addtolength{\textwidth}{1cm}
\setlength{\textheight}{24cm} 	% Hauteur de la zone de texte


% nouvelle commande pour un joli nom
\newcommand{\nom}[1]{\textsc{#1}}

% commande pour une zolie ligne
\newcommand{\ligne}[1][1pt]{
  \par\noindent
  \rule[.5ex]{\linewidth}{#1}\par}

% nettoyer une page blanche avant une page de chapitre en mode openright
\newcommand{\clearemptydoublepage}{
	\newpage{\pagestyle{empty}\cleardoublepage}}


\makeindex

\begin{document}

% augmenter l'espacement entre plusieurs paragraphes plutôt que de passer des lignes quand il faut pas
\setlength{\parskip}{2.4ex}

\title{
\ligne{\Large}\textbf{Project de deuxième année}\\
\Large Intégration des plugins contextd grâce aux ``Linux Security Modules''
% \& Intégration Piga Systrans ?
\ligne{\Large}
} %TODO
\author{\nom{Dimitri Gressin} \& \nom{Timothée Ravier}\\\\\nom{Pilote : Jérémy Briffaut}}
\date{xx xxx 201x} %TODO

% titre
\maketitle

% page blanche
\clearemptydoublepage

% table des matières
\setcounter{secnumdepth}{2}
\setcounter{tocdepth}{2}
\addtocontents{toc}{\protect\thispagestyle{empty}}
\tableofcontents
\addtocounter{page}{-1}

\newpage

\section*{Introduction} \addcontentsline{toc}{section}{Introduction}
Ce rapport présente le travail et les résultats obtenus après x mois dans le cadre de notre projet d'application de deuxième année.
%TODO

~

Le but de ce projet est de remplacer l'écriture de plugins pour contextd par application par un ``plugin'' général. L'idée de départ était d'utiliser Systemtap, un outils développé par ... pour ...
%TODO

~

Ici, ce sera donc plus qu'un plugin puisque les fonctionnalités telles les demandes d'ouverture de fichier, de connexion réseau, seront ``détectées'' par le ``sous-module'' LSM, puis transmisent à contextd.
%TODO

~

%TODO

\newpage

\section{Objectifs}

Il fallait obtenir :
\begin{itemize}
	\item la liste des fichiers créés, ouverts, modifiés par l'ensemble des processus, et les contextes selinux associés
	\item la liste des connexions ouvertes par le systeme et faire correspondre l'adresse ip avec le nom de domaine
\end{itemize}


\section{Systemtap}

\subsection{Principe de fonctionnement}
Nous avons débuter avec Systemtap qui est %TODO

Utilise les KProbes, et les Kretprobes\cite{IBMRBST}.

\begin{figure}[hb]
	\centering
	\includegraphics[scale=0.4]{kretprob.png}
	\caption{Fonctionnement tel que décrit dans la référence IBM sur Systemtap \cite{IBMRBST}}
\end{figure}

\subsection{Résultats obtenus}

Nous avons partiellement atteint ces critères mais nous nous sommes rendu compte d'une particularité de l'implémentation de Systemtap qui ne corespondait pas avec notre besoin final. Nous nous sommes heurté à la simplicité de Systemtap qui vise un apprentissage rapide pour un usage ciblé.

De plus, les instructions décrites dans un script écrit pour Systemtap sont exécutées après que le code de l'appel system correspondant ai été exécuté.

%\includegraphics[scale=0.4]{stap_internals.png} TODO

Cela ne correspond donc pas au besoin de sécurité énoncé précédement.


\newpage


\section{Linux Security Modules}

Nous avons donc décider avec l'accord de Jérémy Briffaut de nous tourner vers les ``Linux Security Modules''.

\subsection{Principe de fonctionnement}

\begin{figure}[hb]
	\centering
	\includegraphics[scale=0.45]{lsm1.png}
	\caption{LSM Hook Architecture \cite{LSMINTRO}}
\end{figure}

\begin{figure}[hb]
	\centering
	\includegraphics[scale=0.45]{lsm2.png}
	\caption{Permissive LSM hook. This hook allows the security policy to override a DAC restriction \cite{LSMINTRO}}
\end{figure}

\newpage

\subsection{Résultats obtenus}

\newpage

\clearemptydoublepage

\section*{Conclusion} \addcontentsline{toc}{section}{Conclusion}

Ce projet aura été pour nous l'occasion d'apprendre un langage de programmation orienté objets, qui nous a permis de gagner en efficacité lors de la phase de développement. En revanche, le fait que nous découvrions le C++ a limité nos possibilités d'optimisations. Le temps de traitement d'un graphe contenant une grande quantité de noeud étant élevé, il paraît nécessaire de paralléliser les algorithmes que nous avons appliqués, pour tirer pleinement partie des machines multi-coeurs ou multi-processeurs, par exemple en utilisant les Intel Threading Building Blocks \cite{IBMRBST}.

De plus, bien que vérifiée, notre implémentation de l'algorithme de décomposition modulaire peut contenir des bugs. Il faut donc prévoir un outils permettant la vérification des résultats obtenus par cette méthode avec ceux obtenus par le parcours simple de graphes. Il sera donc toujours nécessaire de produire l'intégralité des chemins entre deux noeuds à partir du graphe d'origine pour s'assurer que les graphes réduits sont bien justes.

Il faut noter, au vu des résultats, que la décomposition modulaire de graphes permettra fort probablement non seulement d'accélerer le parcours de graphes une fois l'intégralité des chemins générés mais aussi de réduire la taille finale de l'ensemble formé par tous les chemins.

Enfin, notre programme se limite à la décomposition de graphes orientés. Les algorithmes diffèrent de ceux applicables aux graphes non-orientés et leur mise en oeuvre nécessiterai la réécriture d'une grande partie du code pour assurer la rapidité et l'efficacité de notre implémentation.


\newpage
\addcontentsline{toc}{section}{Annexes}
\addcontentsline{toc}{subsection}{Remarques}
\addcontentsline{toc}{subsection}{Liens et références}
\subsection*{Remarques}

Un fichier de configuration est présent avec les sources du kernel 2.6.32-hardened. Il correspond aux options nécessaire à la compilation dans une machine virtuelle Virtualbox. L'option autorisant nos modifications y est aussi activée. Elle est situé dans Security -> SELinux userspace audit.

\subsection*{Liens et références}
\begin{thebibliography}{40}
\bibitem{IBMRBST} \textit{IBM Redbooks : SystemTap: Instrumenting the Linux Kernel for Analyzing Performance and Functional Problems}, \url{http://www.redbooks.ibm.com/abstracts/redp4469.html}

\bibitem{LSMINTRO} \textit{Linux Security Modules : General Security Support for the Linux Kernel}, \url{http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.84.6867&rep=rep1&type=pdf}

\bibitem{SOURCE} Code source (kernel 2.6.32 hardened et scripts systemtap) disponible sur le serveur de projet STI (le projet s'appelle pour l'instant ``Projet LSM''), \url{http://projetsti.ensi-bourges.fr/projects/promo2012-systemtap}.
\end{thebibliography}

%\printindex

\end{document}
